<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>キーボード作曲エディタ + OSMD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- OSMD CDN -->
  <script src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@1.8.6/build/opensheetmusicdisplay.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e5e7eb;
      padding: 16px;
    }
    .app {
      max-width: 1000px;
      margin: 0 auto;
      border-radius: 16px;
      border: 1px solid #1e293b;
      background: #020617;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    h1 {
      font-size: 20px;
      font-weight: 600;
      color: #e5e7eb;
      margin-bottom: 4px;
    }
    .subtitle {
      font-size: 12px;
      color: #9ca3af;
      margin-bottom: 8px;
    }

    .top-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 16px;
      align-items: center;
      padding: 8px 12px;
      border-radius: 12px;
      background: #020617;
      border: 1px solid #1e293b;
      font-size: 13px;
    }
    .top-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .top-label {
      color: #9ca3af;
    }
    select, input[type="number"], input[type="text"] {
      background: #020617;
      color: #e5e7eb;
      border: 1px solid #273549;
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 13px;
      outline: none;
    }
    select:focus, input[type="number"]:focus, input[type="text"]:focus {
      border-color: #4f46e5;
    }
    input[type="number"] {
      width: 60px;
    }
    .time-input {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .main-panel {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px;
      border-radius: 12px;
      background: #020617;
      border: 1px solid #1e293b;
      min-height: 280px;
    }
    #osmd-container {
      background: #f9fafb;
      border-radius: 12px;
      border: 1px solid #111827;
      padding: 8px;
      overflow-x: auto;
      min-height: 200px;
    }

    .status-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 12px;
      color: #9ca3af;
      justify-content: space-between;
      padding: 4px 2px;
    }
    .status-left, .status-right {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .status-pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #1f2937;
      background: rgba(15,23,42,0.7);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .status-label {
      color: #6b7280;
    }
    .status-value {
      color: #e5e7eb;
      font-weight: 500;
    }

    .command-panel {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 10px 12px;
      border-radius: 12px;
      background: #020617;
      border: 1px solid #1e293b;
      font-size: 12px;
    }
    .command-label {
      color: #9ca3af;
    }
    .command-input-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .command-prefix {
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid #111827;
      background: #020617;
      color: #9ca3af;
      font-size: 13px;
    }
    #commandInput {
      flex: 1;
    }

    .help {
      font-size: 11px;
      color: #6b7280;
      line-height: 1.4;
    }
    .help strong {
      color: #e5e7eb;
      font-weight: 500;
    }

    @media (max-width: 640px) {
      .app {
        padding: 12px;
      }
      .top-bar {
        flex-direction: column;
        align-items: flex-start;
      }
      #osmd-container {
        min-height: 160px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <div>
      <h1>キーボード作曲エディタ + OSMD</h1>
      <div class="subtitle">
        上：曲全体の設定　/　中央：楽譜表示　/　下：テキストコマンド　
        ＋ キーボード入力で音符を追加（8キーで和音モード切替）
      </div>
    </div>

    <!-- 上段：曲設定バー -->
    <div class="top-bar">
      <div class="top-group">
        <span class="top-label">Clef</span>
        <select id="clefSelect">
          <option value="treble">Treble (ト音記号)</option>
          <option value="bass">Bass (ヘ音記号)</option>
        </select>
      </div>

      <div class="top-group">
        <span class="top-label">Time</span>
        <div class="time-input">
          <input type="number" id="timeBeats" min="1" max="12" value="4" />
          <span>/</span>
          <input type="number" id="timeBeatType" min="1" max="16" value="4" />
        </div>
      </div>

      <div class="top-group">
        <span class="top-label">Key</span>
        <select id="keySelect">
          <option value="Cmaj">C major</option>
          <option value="Gmaj">G major</option>
          <option value="Dmaj">D major</option>
          <option value="Amaj">A major</option>
          <option value="Emaj">E major</option>
          <option value="Fmaj">F major</option>
          <option value="Bbmaj">Bb major</option>
          <option value="Am">A minor</option>
          <option value="Em">E minor</option>
          <option value="Dm">D minor</option>
        </select>
      </div>

      <div class="top-group">
        <span class="top-label">Tempo</span>
        <input type="number" id="tempoInput" min="20" max="260" value="120" />
        <span class="top-label">BPM</span>
      </div>
    </div>

    <!-- 中央：OSMDエリア＋ステータス -->
    <div class="main-panel">
      <div id="osmd-container"></div>

      <div class="status-bar">
        <div class="status-left">
          <div class="status-pill">
            <span class="status-label">カーソル</span>
            <span class="status-value" id="cursorStatus">0 / 0</span>
          </div>
          <div class="status-pill">
            <span class="status-label">音価</span>
            <span class="status-value" id="durationStatus">quarter (4分)</span>
          </div>
          <div class="status-pill">
            <span class="status-label">Chord</span>
            <span class="status-value" id="chordStatus">OFF</span>
          </div>
        </div>
        <div class="status-right">
          <div class="status-pill">
            <span class="status-label">Undo / Redo</span>
            <span class="status-value">Ctrl+Z / Ctrl+Y</span>
          </div>
        </div>
      </div>
    </div>

    <!-- 下段：コマンドバー＆ヘルプ -->
    <div class="command-panel">
      <div class="command-label">
        コマンドバー（例：<code>tempo 140</code> / <code>time 3/4</code> / <code>clef bass</code> / <code>key Dm</code>）
      </div>
      <div class="command-input-row">
        <span class="command-prefix">:</span>
        <input id="commandInput" type="text" placeholder="コマンドを入力して Enter （先頭の : は省略可）" />
      </div>
      <div class="help">
        <div>
          <strong>音符入力:</strong>
          白鍵 A S D F G H J = C4〜B4 /
          黒鍵 Q W E T Y = C#4〜A#4 /
          R = 休符挿入（現在の音価）
        </div>
        <div>
          <strong>音価変更:</strong>
          1=全音符, 2=2分, 3=4分, 4=8分, 5=16分, 6=32分, 7=64分
        </div>
        <div>
          <strong>和音モード:</strong>
          8 = Chord ON/OFF（ON中は同じ拍に音を積む）
        </div>
        <div>
          <strong>移動と編集:</strong>
          ←→=カーソル移動 / ↑↓=半音上下 / Backspace, Delete=削除
        </div>
      </div>
    </div>
  </div>

  <script>
    // ====== グローバル状態 ======
    const divisions = 64; // quarter note divisions (MusicXML <divisions>)
    let osmd = null;

    // 楽譜データ（単声＋和音）
    // event:
    //  - 単音: { type: "note", pitch: "C4", duration: "quarter", chord?: false }
    //  - 和音の追加音: { type: "note", pitch: "E4", duration: "quarter", chord: true }
    //  - 休符: { type: "rest", duration: "quarter" }
    let score = [];

    // エディタ状態
    let editorState = {
      cursorIndex: 0,
      duration: "quarter", // 現在の音価
      chordMode: false      // 和音モード ON/OFF
    };

    // 曲全体の設定
    let settings = {
      clef: "treble",     // "treble" | "bass"
      timeBeats: 4,       // numerator
      timeBeatType: 4,    // denominator
      key: "Cmaj",        // "Cmaj", "Am" etc
      tempo: 120
    };

    // Undo / Redo用履歴
    let history = [];
    let historyIndex = -1;

    // ====== ユーティリティ ======
    function clone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }

    function getEditorSnapshot() {
      return {
        score: clone(score),
        editorState: clone(editorState),
        settings: clone(settings)
      };
    }

    function applyEditorSnapshot(snap) {
      score = clone(snap.score);
      editorState = clone(snap.editorState);
      settings = clone(snap.settings);
      updateUIFromSettings();
      scheduleRender();
    }

    function pushHistory() {
      // 未来側を切り捨て
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }
      history.push(getEditorSnapshot());
      historyIndex = history.length - 1;
    }

    function undo() {
      if (historyIndex <= 0) return;
      historyIndex--;
      const snap = history[historyIndex];
      applyEditorSnapshot(snap);
    }

    function redo() {
      if (historyIndex >= history.length - 1) return;
      historyIndex++;
      const snap = history[historyIndex];
      applyEditorSnapshot(snap);
    }

    // ====== 音名・半音処理 ======
    // キーからピッチへの簡易マッピング（C4〜B4 + 黒鍵）
    const keyToPitch = {
      // 白鍵（ホームポジション）
      "a": "C4",
      "s": "D4",
      "d": "E4",
      "f": "F4",
      "g": "G4",
      "h": "A4",
      "j": "B4",

      // 黒鍵
      "q": "C#4",
      "w": "D#4",
      "e": "F#4",
      "t": "G#4",
      "y": "A#4"
    };

    // pitch "C#4" などを {step: "C", alter: 1, octave: 4} に分解
    function parsePitch(pitch) {
      const match = /^([A-G])(#|b)?(\d)$/.exec(pitch);
      if (!match) return null;
      const step = match[1];
      const accidental = match[2] || null;
      const octave = parseInt(match[3], 10);
      let alter = 0;
      if (accidental === "#") alter = 1;
      if (accidental === "b") alter = -1;
      return { step, alter, octave };
    }

    // 半音上下用：C4→C#4→D4...
    const stepOrder = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

    function pitchToMidi(pitch) {
      const p = parsePitch(pitch);
      if (!p) return null;
      const baseIndex = stepOrder.indexOf(
        p.step + (p.alter === 1 ? "#" : p.alter === -1 ? "b" : "")
      );
      if (baseIndex < 0) return null;
      // C4 = 60 とする
      const octaveOffset = (p.octave + 1) * 12; // C-1 = 0 → C4 = (4+1)*12=60
      return octaveOffset + baseIndex;
    }

    function midiToPitch(midi) {
      const octave = Math.floor(midi / 12) - 1;
      const index = midi % 12;
      const name = stepOrder[index]; // e.g. "C#"
      const m = /^([A-G])(#)?$/.exec(name);
      const step = m[1];
      const accidental = m[2] ? "#" : "";
      return step + accidental + octave;
    }

    function transposePitch(pitch, semitones) {
      const midi = pitchToMidi(pitch);
      if (midi == null) return pitch;
      return midiToPitch(midi + semitones);
    }

    // ====== duration / type マッピング ======>
    function durationTypeFromDigit(digit) {
      switch (digit) {
        case "1": return "whole";
        case "2": return "half";
        case "3": return "quarter";
        case "4": return "eighth";
        case "5": return "16th";
        case "6": return "32nd";
        case "7": return "64th";
        default: return null;
      }
    }

    function durationLabel(type) {
      switch (type) {
        case "whole":   return "whole (全音符)";
        case "half":    return "half (2分)";
        case "quarter": return "quarter (4分)";
        case "eighth":  return "eighth (8分)";
        case "16th":    return "16th (16分)";
        case "32nd":    return "32nd (32分)";
        case "64th":    return "64th (64分)";
        default:        return type;
      }
    }

    function durationToDivisions(type) {
      // divisions = 64 per quarter
      switch (type) {
        case "whole":   return 256; // 4 * 64
        case "half":    return 128; // 2 * 64
        case "quarter": return 64;
        case "eighth":  return 32;
        case "16th":    return 16;
        case "32nd":    return 8;
        case "64th":    return 4;
        default:        return 64;
      }
    }

    function typeToMusicXMLType(type) {
      switch (type) {
        case "whole":   return "whole";
        case "half":    return "half";
        case "quarter": return "quarter";
        case "eighth":  return "eighth";
        case "16th":    return "16th";
        case "32nd":    return "32nd";
        case "64th":    return "64th";
        default:        return "quarter";
      }
    }

    // ====== Key Signature マッピング ======
    const keySignatures = {
      "Cmaj":  { fifths: 0, mode: "major" },
      "Gmaj":  { fifths: 1, mode: "major" },
      "Dmaj":  { fifths: 2, mode: "major" },
      "Amaj":  { fifths: 3, mode: "major" },
      "Emaj":  { fifths: 4, mode: "major" },
      "Fmaj":  { fifths: -1, mode: "major" },
      "Bbmaj": { fifths: -2, mode: "major" },

      "Am":    { fifths: 0, mode: "minor" },
      "Em":    { fifths: 1, mode: "minor" },
      "Dm":    { fifths: -1, mode: "minor" }
    };

    // ====== MusicXML 生成 ======
    function generateMusicXML() {
      const beats = settings.timeBeats;        // 例: 4
      const beatType = settings.timeBeatType;  // 例: 4

      const keyInfo = keySignatures[settings.key] || keySignatures["Cmaj"];

      // 1小節 = beats 個の「beatType分音符」
      // beatType分音符 = (4 / beatType) 個の4分音符
      // → 1小節 = beats * divisions * 4 / beatType
      const measureMax = beats * (divisions * 4 / beatType);

      let xmlParts = [];
      xmlParts.push(`<?xml version="1.0" encoding="UTF-8" standalone="no"?>`);
      xmlParts.push(`<score-partwise version="3.1">`);
      xmlParts.push(`<part-list><score-part id="P1"><part-name>Music</part-name></score-part></part-list>`);
      xmlParts.push(`<part id="P1">`);

      let measureIndex = 1;
      let currentMeasureDuration = 0;

      function openMeasure() {
        xmlParts.push(`<measure number="${measureIndex}">`);
        if (measureIndex === 1) {
          xmlParts.push(`<attributes>`);
          xmlParts.push(`<divisions>${divisions}</divisions>`);
          xmlParts.push(`<key><fifths>${keyInfo.fifths}</fifths><mode>${keyInfo.mode}</mode></key>`);
          xmlParts.push(`<time><beats>${beats}</beats><beat-type>${beatType}</beat-type></time>`);
          if (settings.clef === "bass") {
            xmlParts.push(`<clef><sign>F</sign><line>4</line></clef>`);
          } else {
            xmlParts.push(`<clef><sign>G</sign><line>2</line></clef>`);
          }
          xmlParts.push(`</attributes>`);
          xmlParts.push(
            `<direction placement="above"><direction-type><metronome>` +
            `<beat-unit>quarter</beat-unit><per-minute>${settings.tempo}</per-minute>` +
            `</metronome></direction-type><sound tempo="${settings.tempo}"/></direction>`
          );
        }
      }

      function closeMeasure() {
        xmlParts.push(`</measure>`);
      }

      function writeEvent(ev, dur, isChordNote) {
        if (ev.type === "rest") {
          xmlParts.push(`<note>`);
          xmlParts.push(`<rest/>`);
          xmlParts.push(`<duration>${dur}</duration>`);
          xmlParts.push(`<type>${typeToMusicXMLType(ev.duration)}</type>`);
          xmlParts.push(`</note>`);
        } else if (ev.type === "note") {
          xmlParts.push(`<note>`);
          if (isChordNote) {
            xmlParts.push(`<chord/>`);
          }
          const p = parsePitch(ev.pitch);
          if (!p) {
            xmlParts.push(`</note>`);
            return;
          }
          xmlParts.push(`<pitch>`);
          xmlParts.push(`<step>${p.step}</step>`);
          if (p.alter !== 0) {
            xmlParts.push(`<alter>${p.alter}</alter>`);
          }
          xmlParts.push(`<octave>${p.octave}</octave>`);
          xmlParts.push(`</pitch>`);
          xmlParts.push(`<duration>${dur}</duration>`);
          xmlParts.push(`<type>${typeToMusicXMLType(ev.duration)}</type>`);
          xmlParts.push(`</note>`);
        }
      }

      openMeasure();

      if (score.length === 0) {
        const dur = measureMax || (divisions * 4);
        xmlParts.push(`<note><rest/><duration>${dur}</duration><type>whole</type></note>`);
      } else {
        for (let i = 0; i < score.length; i++) {
          const ev = score[i];
          const dur = durationToDivisions(ev.duration || "quarter");
          const isChordNote = (ev.type === "note" && ev.chord);

          // 和音追加音は拍を増やさないので小節チェックから除外
          if (!isChordNote) {
            if (currentMeasureDuration + dur > measureMax && currentMeasureDuration > 0) {
              closeMeasure();
              measureIndex++;
              currentMeasureDuration = 0;
              openMeasure();
            }
          }

          writeEvent(ev, dur, isChordNote);

          if (!isChordNote) {
            currentMeasureDuration += dur;
          }
        }
      }

      closeMeasure();
      xmlParts.push(`</part>`);
      xmlParts.push(`</score-partwise>`);
      return xmlParts.join("");
    }

    // ====== OSMD レンダリング ======
    let renderTimer = null;

    function scheduleRender() {
      if (!osmd) return;
      if (renderTimer) clearTimeout(renderTimer);
      renderTimer = setTimeout(renderWithOSMD, 200);
      updateStatusBar();
    }

    async function renderWithOSMD() {
      const xml = generateMusicXML();
      try {
        await osmd.load(xml);
        osmd.render();
        updateOsmdCursor();
      } catch (e) {
        console.error("OSMD render error", e);
      }
    }

    function updateOsmdCursor() {
      if (!osmd || !osmd.cursor) return;
      try {
        osmd.cursor.reset();
        osmd.cursor.show();
        let steps = Math.min(editorState.cursorIndex, score.length);
        for (let i = 0; i < steps; i++) {
          if (osmd.cursor.Iterator && osmd.cursor.Iterator.EndReached) break;
          osmd.cursor.next();
        }
      } catch (e) {
        console.warn("cursor update failed", e);
      }
    }

    // ====== ステータスバー更新 ======>
    function updateStatusBar() {
      const cursorStatus = document.getElementById("cursorStatus");
      const durationStatus = document.getElementById("durationStatus");
      const chordStatus = document.getElementById("chordStatus");
      cursorStatus.textContent = `${editorState.cursorIndex} / ${score.length}`;
      durationStatus.textContent = durationLabel(editorState.duration);
      if (chordStatus) {
        chordStatus.textContent = editorState.chordMode ? "ON" : "OFF";
      }
    }

    // ====== UI と settings 同期 ======
    function updateUIFromSettings() {
      document.getElementById("clefSelect").value = settings.clef;
      document.getElementById("timeBeats").value = settings.timeBeats;
      document.getElementById("timeBeatType").value = settings.timeBeatType;
      document.getElementById("keySelect").value = settings.key;
      document.getElementById("tempoInput").value = settings.tempo;
      updateStatusBar();
    }

    function attachUIEvents() {
      document.getElementById("clefSelect").addEventListener("change", (e) => {
        settings.clef = e.target.value;
        pushHistory();
        scheduleRender();
      });

      document.getElementById("timeBeats").addEventListener("change", (e) => {
        const v = parseInt(e.target.value, 10) || 4;
        settings.timeBeats = Math.max(1, v);
        pushHistory();
        scheduleRender();
      });

      document.getElementById("timeBeatType").addEventListener("change", (e) => {
        const v = parseInt(e.target.value, 10) || 4;
        settings.timeBeatType = Math.max(1, v);
        pushHistory();
        scheduleRender();
      });

      document.getElementById("keySelect").addEventListener("change", (e) => {
        settings.key = e.target.value;
        pushHistory();
        scheduleRender();
      });

      document.getElementById("tempoInput").addEventListener("change", (e) => {
        const v = parseInt(e.target.value, 10) || 120;
        settings.tempo = Math.min(260, Math.max(20, v));
        pushHistory();
        scheduleRender();
      });

      const commandInput = document.getElementById("commandInput");
      commandInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          const text = commandInput.value.trim();
          if (text.length > 0) {
            handleCommand(text);
          }
          commandInput.value = "";
        }
      });
    }

    // ====== コマンド処理 ======
    function handleCommand(raw) {
      let text = raw.trim();
      if (text.startsWith(":")) {
        text = text.slice(1).trim();
      }
      if (!text) return;
      const [cmd, ...rest] = text.split(/\s+/);
      const arg = rest.join(" ");

      switch (cmd.toLowerCase()) {
        case "tempo": {
          const v = parseInt(arg, 10);
          if (!isNaN(v)) {
            pushHistory();
            settings.tempo = Math.min(260, Math.max(20, v));
            scheduleRender();
          }
          break;
        }
        case "time": {
          const m = /^(\d+)\s*\/\s*(\d+)$/.exec(arg);
          if (m) {
            pushHistory();
            settings.timeBeats = parseInt(m[1], 10);
            settings.timeBeatType = parseInt(m[2], 10);
            scheduleRender();
          }
          break;
        }
        case "clef": {
          const v = arg.toLowerCase();
          if (v === "treble" || v === "g") {
            pushHistory();
            settings.clef = "treble";
            scheduleRender();
          } else if (v === "bass" || v === "f") {
            pushHistory();
            settings.clef = "bass";
            scheduleRender();
          }
          break;
        }
        case "key": {
          const v = arg.trim();
          if (keySignatures[v]) {
            pushHistory();
            settings.key = v;
            scheduleRender();
          }
          break;
        }
        default:
          console.log("unknown command:", cmd, arg);
      }
    }

    // ====== キーボード操作 ======
    function handleKeyDown(e) {
      const active = document.activeElement;
      if (active && (active.tagName === "INPUT" || active.tagName === "TEXTAREA")) {
        // コマンド欄や数値入力中はグローバルショートカットを止める
        return;
      }

      // ===== 和音モード切替（8） =====
      if (e.key === "8") {
        e.preventDefault();
        editorState.chordMode = !editorState.chordMode;
        updateStatusBar();
        return;
      }

      // Undo / Redo
      if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === "z") {
        e.preventDefault();
        undo();
        return;
      }
      if ((e.ctrlKey || e.metaKey) &&
          (e.key.toLowerCase() === "y" || (e.shiftKey && e.key.toLowerCase() === "z"))) {
        e.preventDefault();
        redo();
        return;
      }

      // カーソル移動
      if (e.key === "ArrowLeft") {
        e.preventDefault();
        editorState.cursorIndex = Math.max(0, editorState.cursorIndex - 1);
        scheduleRender();
        return;
      }
      if (e.key === "ArrowRight") {
        e.preventDefault();
        editorState.cursorIndex = Math.min(score.length, editorState.cursorIndex + 1);
        scheduleRender();
        return;
      }

      // 半音上下
      if (e.key === "ArrowUp" || e.key === "ArrowDown") {
        e.preventDefault();
        const ev = score[editorState.cursorIndex];
        if (ev && ev.type === "note") {
          pushHistory();
          const delta = e.key === "ArrowUp" ? 1 : -1;
          ev.pitch = transposePitch(ev.pitch, delta);
          scheduleRender();
        }
        return;
      }

      // 削除
      if (e.key === "Backspace" || e.key === "Delete") {
        e.preventDefault();
        if (score.length > 0 && editorState.cursorIndex > 0 && editorState.cursorIndex <= score.length) {
          pushHistory();
          score.splice(editorState.cursorIndex - 1, 1);
          editorState.cursorIndex = Math.max(0, editorState.cursorIndex - 1);
          scheduleRender();
        } else if (score.length > 0 && editorState.cursorIndex === 0) {
          // 先頭を消す
          pushHistory();
          score.splice(0, 1);
          editorState.cursorIndex = 0;
          scheduleRender();
        }
        return;
      }

      // 音価変更（1〜7）
      if (/^[1-7]$/.test(e.key)) {
        e.preventDefault();
        const t = durationTypeFromDigit(e.key);
        if (t) {
          editorState.duration = t;
          updateStatusBar();
        }
        return;
      }

      // 休符挿入
      if (e.key.toLowerCase() === "r") {
        e.preventDefault();
        pushHistory();
        const ev = { type: "rest", duration: editorState.duration };
        score.splice(editorState.cursorIndex, 0, ev);
        editorState.cursorIndex++;
        scheduleRender();
        return;
      }

      // 音符挿入（白鍵 + 黒鍵）
      const keyLower = e.key.toLowerCase();
      if (keyToPitch[keyLower]) {
        e.preventDefault();
        pushHistory();
        const pitch = keyToPitch[keyLower];

        // 和音モード中 & 直前にノートがある場合はそのノートに重ねる
        if (editorState.chordMode && editorState.cursorIndex > 0 && score.length > 0) {
          const anchorIndex = editorState.cursorIndex - 1;
          const anchor = score[anchorIndex];
          if (anchor && anchor.type === "note") {
            const dur = anchor.duration || editorState.duration;
            const ev = { type: "note", pitch, duration: dur, chord: true };
            // カーソル位置に挿入（アンカーの後ろ、次のイベントの前）
            score.splice(editorState.cursorIndex, 0, ev);
            // 和音追加音ではカーソルは進めない
            scheduleRender();
            return;
          }
        }

        // 通常の単音挿入
        const ev = { type: "note", pitch, duration: editorState.duration, chord: false };
        score.splice(editorState.cursorIndex, 0, ev);
        editorState.cursorIndex++;
        scheduleRender();
        return;
      }
    }

    // ====== 初期化 ======
    window.addEventListener("load", () => {
      osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay("osmd-container", {
        drawingParameters: "compact"
      });

      attachUIEvents();
      updateUIFromSettings();

      // 空状態を履歴に一発積んでおく
      pushHistory();
      scheduleRender();

      window.addEventListener("keydown", handleKeyDown);
    });
  </script>
</body>
</html>
